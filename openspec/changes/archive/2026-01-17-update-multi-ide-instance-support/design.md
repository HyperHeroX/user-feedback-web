# Design: Multi-IDE Instance Support (Simplified)

## Context

當前 user-feedback 系統使用全局鎖定檔案來確保單一實例運行。原先設計考慮使用 IDE 識別（PPID + 環境變數）來區分不同 IDE 實例，但這增加了不必要的複雜性。

簡化方案：採用「端口逃避」策略，當目標端口被佔用時直接遞增到下一個可用端口，不嘗試識別或管理現有實例。

## Goals / Non-Goals

### Goals
- 多個 IDE 實例可同時運行各自的 user-feedback 服務
- 當端口被佔用時，自動使用下一個可用端口
- 保持實現簡單，易於理解和維護
- 不干擾或終止現有運行中的實例

### Non-Goals
- ~~識別不同 IDE 實例~~（已移除）
- ~~基於 IDE 識別的鎖定檔案~~（已移除）
- ~~同一 IDE 內的實例重用~~（已移除）
- 跨實例共享 session 或資料
- 實例間通訊或負載平衡

## Decisions

### 1. 端口逃避策略

**決定**: 當目標端口被佔用時，自動遞增到下一個可用端口

**行為**:
1. 嘗試在配置的端口（預設 5050）啟動
2. 如果端口被佔用，嘗試 5051, 5052, ... 直到找到可用端口
3. 不檢查佔用者是誰，不嘗試連接現有實例
4. 每個實例獨立運行，互不干擾

**理由**:
- 實現簡單，無需複雜的進程識別邏輯
- 行為可預測，避免意外終止其他實例
- 利用現有 `PortManager` 基礎設施

### 2. 移除 IDE 識別機制

**決定**: 不再使用 PPID 或 `MCP_IDE_IDENTIFIER` 來識別 IDE 實例

**理由**:
- PPID 在不同環境下行為不一致（Docker、SSH、終端多工器）
- 增加了不必要的複雜性
- 端口逃避策略已足夠解決多實例需求

### 3. 簡化鎖定檔案

**決定**: 保持使用單一鎖定檔案 `.user-feedback.lock`，但僅用於防止同一端口的重複啟動

**行為**:
1. 鎖定檔案記錄 PID、端口、啟動時間
2. 啟動時檢查鎖定檔案
3. 如果鎖定檔案存在且進程存活，則認為端口可能被佔用，直接嘗試下一個端口
4. 如果鎖定檔案存在但進程已終止，清理過期鎖定

### 4. 啟動流程

```
startup:
  1. 讀取配置的端口（預設 5050）
  2. 檢查端口是否可用
     - 可用: 啟動服務，寫入鎖定檔案
     - 被佔用: 遞增端口號，重試步驟 2
  3. 啟動成功後記錄使用的端口
  4. 日誌顯示最終使用的端口
```

## Risks / Trade-offs

| Risk | Mitigation |
|------|------------|
| 端口號無限遞增 | 設定最大嘗試次數（預設 10） |
| 用戶不知道實際使用的端口 | 啟動日誌清楚顯示端口號 |
| 多實例消耗更多資源 | 這是預期行為，用戶可自行管理 |

## Migration Plan

1. 現有單一實例用戶無影響（默認行為不變）
2. 多 IDE 用戶將獲得獨立實例而非連接到現有實例
3. 移除 `MCP_IDE_IDENTIFIER` 環境變數支援
4. 保持單一鎖定檔案格式（向後相容）

## Open Questions

- 無（設計已簡化）
